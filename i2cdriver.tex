\documentclass{article}

\usepackage{booktabs}
\usepackage{fancyhdr}
\usepackage{float}
\usepackage{graphicx}
\usepackage{helvet}
\usepackage{hyperref}
\usepackage{tabularx}
\usepackage{xcolor}

\usepackage{listings}
\usepackage{tikz}

\usepackage{makeidx}         % allows index generation
\makeindex

\lstset{frame=tblr,
  rulecolor=\color{lightgray},
  language=Java,
  aboveskip=5mm,
  belowskip=5mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle=\linespread{1.0}\small\ttfamily,
  numbers=none,
  % numberstyle=\tiny\color{gray},
  % keywordstyle=\color{blue},
  % commentstyle=\color{dkgreen},
  % stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3
}

\usepackage{framed}     % These needed for the code formatter
\usepackage{color}
\usepackage{fancyvrb}

% Use helvetica (sans) by default
\renewcommand{\familydefault}{\sfdefault}

% Greenish links
\hypersetup{
  colorlinks=true,
  linkcolor=blue!50!red,
  urlcolor=blue!50!red
}

\newcommand{\two}{\raise0.5ex\hbox{\footnotesize{2}}}

\newcommand{\iic}{I\two{}C}
\newcommand{\iicdriver}{I\two{}CDriver}
\newcommand{\degc}{$^{\circ}$C}

\setlength{\headheight}{40pt}
\setlength{\headsep}{0.2in}

\pagestyle{fancy}
\lhead{\includegraphics[width=0.2\textwidth]{img/logo}}
\chead{\iicdriver{} User Guide}
\rhead{\thepage}
\cfoot{\textcopyright \the\year \ \ Excamera Labs}
\renewcommand{\headrulewidth}{0.5pt}
\renewcommand{\footrulewidth}{0.5pt}

\usepackage{array}
\newcolumntype{L}[1]{>{\raggedright\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}
\newcolumntype{C}[1]{>{\centering\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}
\newcolumntype{R}[1]{>{\raggedleft\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}

\usepackage{setspace}

\newcommand{\heavyline}{\specialrule{1pt}{1pt}{1pt}}
\newcommand{\png}[1]{
\begin{figure}[H]
\begin{center}
\includegraphics[width=0.75\textwidth]{#1}
\end{center}
\end{figure}
}
\newcommand{\pngw}[2]{
\begin{figure}[H]
\begin{center}
\includegraphics[width=#2\textwidth]{#1}
\end{center}
\end{figure}
}

\usepackage{sphinx}

\newcommand{\mach}[1]{\texttt{\textbf{#1}}}
\newcommand{\gap}{\vspace{10pt}}

\newcommand\encircle[1]{%
  \tikz[baseline=(X.base)] 
   \node (X) [draw, shape=circle, inner sep=0] {\strut #1};}

\input{pyg.tex}

\begin{document}

\newpage
\begin{center}
\includegraphics[width=1.00\textwidth]{img/i2cdriver/hero}
Last updated on \today
\end{center}
\tableofcontents

\newpage

\setlength{\parindent}{0mm}
\setlength{\parskip}{1mm}
\setstretch{1.4}

\section{Overview}

\iicdriver{} is an easy-to-use, open source tool for controlling \iic{} devices. It works with Windows, Mac, and Linux, and has a built-in color screen that shows a live “dashboard” of all the \iic{} activity. It uses a standard FTDI USB serial chip to talk to the PC, so no special drivers need to be installed. The board includes a separate 3.3 V supply with voltage and current monitoring.

\subsection{Features}
\begin{itemize}
\item \textbf{Live display}: shows you exactly what it's doing all the time  
\item \textbf{Supports all \iic{} features}: 7- and 10-bit \iic{} addressing, clock stretching, bus arbitration,
and sustained \iic{} transfers at 400 and 100 kHz  
\item \textbf{\iic{} pullups}: programmable \iic{} pullup resistors, with automatic tuning  
\item \textbf{USB voltage monitoring}: USB line voltage monitor to detect supply problems, to 0.01 V  
\item \textbf{Target power monitoring}: target device high-side current measurement, to 5 mA  
\item \textbf{Three \iic{} ports}: three identical \iic{} ports, each with power and \iic{} signals  
\item \textbf{Jumpers}: three sets of high-quality color coded 100mm jumpers included
\item \textbf{3.3 V output}: output levels are 3.3 V, all are 5 V tolerant  
\item \textbf{Sturdy componentry}: uses an FTDI USB serial adapter, and Silicon Labs automotive-grade EFM8 controller  
\item \textbf{Open hardware}: the design, firmware and all tools are under BSD license
\item \textbf{Flexible control}: GUI, command-line, C/C++, and Python 2/3 host software provided for Windows, Mac, and Linux  
\end{itemize}

\newpage
\section{Getting Started}

When you first connect \iicdriver{} to the USB port, the display blinks white for a moment then shows something like this:

\png{img/i2cdriver/DSC_9039}

Connect the three sets of colored hookup wires as shown,
following the same sequence as on the colored label:

\gap
\begin{center}
\begin{tabular}{ll}
\hline
\mach{GND}  & black \\
\mach{VCC}  & red \\
\mach{SDA}  & blue \\
\mach{SCL}  & yellow \\
\hline
\end{tabular}
\end{center}
\gap

The top two signals carry power, the VCC line supplies 3.3 volts.

Across the top of the display \iicdriver{} continuously measures the USB bus voltage
and the current output.

\newpage
\section{Software installation}

The source for all the \iicdriver{} software is the
\href{https://github.com/jamesbowman/i2cdriver}{repository}.
Available are:

\begin{itemize}
\item a Windows/Mac/Linux GUI
\item a Windows/Mac/Linux command-line
\item Python 2 and 3 bindings
\item Windows/Mac/Linux C/C++ bindings
\end{itemize}

Installation of the GUI and command-line utilities varies by platform.

\subsection{Windows}\index{drivers!Windows}

This
\href{https://i2cdriver.com/windows}{installer}
contains the GUI and command-line utilities.

The GUI shortcut is installed on the desktop:

\pngw{img/i2cdriver/win32-icon}{.3}

launching it brings up the control window:

\pngw{img/i2cdriver/win32-gui}{1.0}

If there is only one serial device, 
the \iicdriver{} device should be automatically selected.
If there is more than one device, select its COM port from the pulldown menu at the top.
Once connected, you can select a connected \iic{} device and write and read data. 

The command line utility \mach{i2ccl} is also installed. For example to display status information:

\begin{lstlisting}
c:\>"c:\Program Files\Excamera Labs\I2CDriver\i2ccl.exe" COM6 i
uptime 8991  4.957 V  30 mA  25.8 C SDA=1 SCL=1 speed=100 kHz
\end{lstlisting}

See below for more information on the command-line syntax.

\subsection{Linux}\index{drivers!Linux}

The GUI is included in the \mach{i2cdriver} Python package, compatible with both Python 2 and 3.
To install it, open a shell prompt and do:

\begin{lstlisting}
sudo pip install i2cdriver
\end{lstlisting}

Then run it with

\begin{lstlisting}
i2cgui.py
\end{lstlisting}

For the command-line tool, clone the
\href{https://github.com/jamesbowman/i2cdriver}{repository},
then do:

\begin{lstlisting}
cd i2cdriver/c
make -f linux/Makefile
sudo make -f linux/Makefile install
i2ccl /dev/ttyUSB0 i
\end{lstlisting}

and you should see something like:

\begin{lstlisting}
uptime 1651  4.971 V  0 mA  21.2 C SDA=1 SCL=1 speed=100 kHz
\end{lstlisting}

\subsection{MacOS}\index{drivers!Mac}

The GUI is included in the \mach{i2cdriver} Python package, compatible with both Python 2 and 3.
To install it, open a shell prompt and do:

\begin{lstlisting}
sudo pip install i2cdriver
\end{lstlisting}

Then run it with

\begin{lstlisting}
i2cgui.py
\end{lstlisting}

For the command-line tool, clone the
\href{https://github.com/jamesbowman/i2cdriver}{repository}
, then do:

\begin{lstlisting}
cd i2cdriver/c
make -f linux/Makefile
sudo make -f linux/Makefile install
i2ccl /dev/cu.usbserial-DO00QS8D i
\end{lstlisting}

(substituting your actual \iicdriver{}'s ID for \mach{DO00QS8D})
and you should see something like:

\begin{lstlisting}
uptime 1651  4.971 V  5 mA  21.2 C SDA=1 SCL=1 speed=100 kHz
\end{lstlisting}

Note that the port to use is \mach{/dev/cu.usbserial-XXXXXXXX}, as explained
\href{https://pbxbook.com/other/mac-tty.html}{here}.

\newpage
\section{APIs}

\subsection{Python 2 and 3}\index{drivers!Python}

The \iicdriver{} bindings can be installed with \mach{pip} like this:

\begin{lstlisting}
  pip install i2cdriver
\end{lstlisting}

then from Python you can read an LM75B temperature sensor with:
\index{Example!LM75B}

\begin{lstlisting}
>>> import i2cdriver
>>> i2c = i2cdriver.I2CDriver("/dev/ttyUSB0")
>>> d=i2cdriver.EDS.Temp(i2c)
>>> d.read()
17.875
>>> d.read()
18.0
\end{lstlisting}

You can print a bus scan with:\index{bus scan}

\begin{lstlisting}
>>> i2c.scan()
-- -- -- -- -- -- -- -- 
-- -- -- -- -- -- -- -- 
-- -- -- -- 1C -- -- -- 
-- -- -- -- -- -- -- -- 
-- -- -- -- -- -- -- -- 
-- -- -- -- -- -- -- -- 
-- -- -- -- -- -- -- -- 
-- -- -- -- -- -- -- -- 
48 -- -- -- -- -- -- -- 
-- -- -- -- -- -- -- -- 
-- -- -- -- -- -- -- -- 
-- -- -- -- -- -- -- -- 
68 -- -- -- -- -- -- -- 
-- -- -- -- -- -- -- -- 
[28, 72, 104]
\end{lstlisting}

The Python GUI (which uses \href{https://www.wxpython.org/pages/downloads/}{wxPython}) can be run with:

\begin{lstlisting}
python i2cgui.py
\end{lstlisting}

which depending on your distribution looks something like this:

\png{img/i2cdriver/win32-gui}

There are more examples in the 
\href{https://github.com/jamesbowman/i2cdriver/tree/master/python/samples}{samples folder in the repository}.

The module has extensive help strings:
\begin{lstlisting}
>>> help(i2cdriver)
\end{lstlisting}
displays the API documentation.

\newpage
\subsubsection{Reference}
\let\spxentry \sphinxstyleindexentry
\let\spxextra \sphinxstyleindexextra

\input{i2csphinx.tex}

\subsection{C/C++}\index{drivers!C/C++}

\iicdriver{} is contained in a single source file with a single header.
Both are in \href{https://github.com/jamesbowman/i2cdriver/tree/master/c/common}{this subdirectory}.
Usage follows the Python API and is fairly self-explanatory.

\newpage
\section{Using \iicdriver{}}
\subsection{The display}\index{display}

The main display on the screen has three sections.
\index{heat-map}
The top section is a heat-map showing all 112 legal \iic{} addresses. Devices that are currently active are white. Inactive devices fade to yellow, purple and finally blue.
The middle section is a symbolic interpretation of current \iic{} traffic. Details on this are below.
The bottom two lines show a representation of the SDA (blue) and SCL (yellow) signals.

\png{img/i2cdriver/hero2}
\index{symbols}
The symbolic decode section shows \iic{} transactions as they happen.
Start and stop are shown as
\encircle{\textbf{S}}
and
\encircle{\textbf{P}}
symbols.
After a
\encircle{\textbf{S}}
symbol the address byte is shown, with a right arrow (write) or left arrow (read). There are gray lines connecting the address byte to its heat-map indicator.
Following this is a series of data bytes.
Each byte is shown in hex, with either a green dot (ACK) or red dot (NACK).

\png{img/i2cdriver/hero3}

So for example the above sequence is showing

\begin{itemize}
\item Start, write to address \mach{45}
\item Write byte \mach{7A}
\item Repeated Start, read from address \mach{45}
\item Read byte \mach{00}
\item Read byte \mach{A2}
\item Stop
\end{itemize}

The above sequence is very typical for reading registers from an \iic{} Device.
Note that the final NACK (red dot) is not an error condition, but the standard way of handling the last byte of read transaction.

\subsection{The GUI}\index{GUI}
\subsection{The command-line tool \mach{i2ccl}}

\mach{i2ccl} is the same on all platforms.

The first parameter to the command is the serial port, which depends on your operating system.
All following parameters are control commands. These are:

\begin{tabular}{ll}
  \mach{i}               & display status information (uptime, voltage, current, temperature) \\
  \mach{d}               & device scan \index{bus scan} \\
  \mach{w} $dev$ $bytes$ & write $bytes$ to \iic{} device $dev$ \\
  \mach{p}               & send a STOP \\
  \mach{r} $dev$ $N$     & read $N$ bytes from \iic{} device $dev$, then STOP \\
  \mach{m}               & enter \iic{} bus monitor mode \\
\end{tabular}\gap

For example the command:

\begin{lstlisting}
  i2ccl /dev/ttyUSB0 r 0x48 2
\end{lstlisting}

reads two bytes from the \iic{} device at address 0x48.
So with an
\href{https://www.nxp.com/docs/en/data-sheet/LM75B.pdf}{LM75B temperature sensor}
\index{Example!LM75B}
connected you might see output like:

\begin{lstlisting}
  0x16,0x20
\end{lstlisting}

which indicates a temperature of about 22 \degc.

\iic{} devices usually have multiple registers. \index{register read}
To read register 3 of the LM75B, you first write the register address 3, then read two bytes as before:

\begin{lstlisting}
  i2ccl /dev/ttyUSB0 w 0x48 3 r 0x48 2
  0x50,0x00
\end{lstlisting}

Which shows that register 3 has the value \mach{0x5000}.

\subsection{Monitor mode}\index{Monitor mode}

In monitor mode, the \iicdriver{} does not write any data to the \iic{} bus.
Instead it monitors bus traffic and draws it on the display.
This makes it an ideal tool for troubleshooting and debugging \iic{} hardware and software.

To show that it is in monitor mode, the \iicdriver{} changes the character in the top-left of the display from \mach{D} to \mach{M}.

There are several ways of entering monitor mode:

\begin{itemize}
\item use the command-line tool:

\begin{lstlisting}
    i2ccl m
\end{lstlisting}

\item from the GUI check the "Monitor" box
\item from Python issue:

\begin{lstlisting}
    i2c.monitor(True)
\end{lstlisting}
  
and to exit:

\begin{lstlisting}
    i2c.monitor(False)
\end{lstlisting}

\item connect a terminal to the \iicdriver{} (at 1000000 8N1) and type the \mach{m} character, then type any character to exit monitor mode
\end{itemize}

\subsection{Capture mode}\index{Capture mode}
\subsubsection{Command line}\index{capture.py@\mach{capture.py}}

There is a Python sample program that can be used to capture traffic on the command-line at
\href{https://github.com/jamesbowman/i2cdriver/blob/master/python/samples/capture.py}{\mach{capture.py}}.

Running it with the \iicdriver{} address as an argument puts the \iicdriver{} into capture mode:
the character in the top-left of the display changes from \mach{D} to \mach{C}.

\begin{lstlisting}
$ python samples/capture.py /dev/ttyUSB0

Now capturing traffic to
    standard output (human-readable)
    log.csv
Hit CTRL-C to leave capture mode
<START 0x14 WRITE ACK>
<WRITE 0x02 ACK>
<WRITE 0x22 ACK>
<STOP>
^C
Capture finished
\end{lstlisting}

When run, it displays any traffic on standard output.
It also writes a traffic summary to \mach{log.csv} which
can be examined and processed by any tool that can accept CSV files.

\png{img/i2cdriver/csv}

The GUI also supports capture to CSV file.

\png{img/i2cdriver/win32-gui-capture}

Clicking ``Capture mode'' starts the capture
and prompts for a destination CSV file.
The character in the top-left of the display changes from \mach{D} to \mach{C}.
Capture continues until you click ``Capture mode'' again.

\section{Examples}

The Python \mach{samples} directory contains short examples of using all
\href{https://electricdollarstore.com}{Electric Dollar Store} \iic{} modules:\gap

\begin{center}\begin{tabular}{lll}
\hline
Module & Function                 & Sample \\
\hline
DIG2   & 2-digit 7-seg display    & \href{https://github.com/jamesbowman/i2cdriver/blob/master/python/samples/EDS-DIG2.py}{EDS-DIG2.py} \\
LED    & RGB LED                  & \href{https://github.com/jamesbowman/i2cdriver/blob/master/python/samples/EDS-LED.py}{EDS-LED.py} \\
POT    & potentiometer            & \href{https://github.com/jamesbowman/i2cdriver/blob/master/python/samples/EDS-POT.py}{EDS-POT.py} \\
BEEP   & Piezo beeper             & \href{https://github.com/jamesbowman/i2cdriver/blob/master/python/samples/EDS-BEEP.py}{EDS-BEEP.py} \\
REMOTE & IR remote receiver       & \href{https://github.com/jamesbowman/i2cdriver/blob/master/python/samples/EDS-REMOTE.py}{EDS-REMOTE.py} \\
EPROM  & CAT24C512 64 Kbyte EPROM & \href{https://github.com/jamesbowman/i2cdriver/blob/master/python/samples/EDS-EPROM.py}{EDS-EPROM.py} \\
MAGNET & LIS3MDL magnetometer     & \href{https://github.com/jamesbowman/i2cdriver/blob/master/python/samples/EDS-MAGNET.py}{EDS-MAGNET.py} \\
TEMP   & LM75B temperature sensor & \href{https://github.com/jamesbowman/i2cdriver/blob/master/python/samples/EDS-TEMP.py}{EDS-TEMP.py} \\
ACCEL  & RT3000C Accelerometer    & \href{https://github.com/jamesbowman/i2cdriver/blob/master/python/samples/EDS-ACCEL.py}{EDS-ACCEL.py} \\
CLOCK  & HT1382 real-time clock   & \href{https://github.com/jamesbowman/i2cdriver/blob/master/python/samples/EDS-CLOCK.py}{EDS-CLOCK.py} \\
\hline
\end{tabular}\end{center}\gap


All demos and applications are run the same way, supplying the \iicdriver{} on the command-line. For example:

\begin{lstlisting}
python EDS-LED.py COM16
\end{lstlisting}

Also included are some small applications which demonstrate combinations of modules.

\subsection{Color Compass}\index{Example!Compass}\index{Example!RGB}\index{Example!Magnetometer}

Source code: \href{https://github.com/jamesbowman/i2cdriver/blob/master/python/samples/EDS-color-compass.py}{EDS-color-compass.py}

Color compass uses MAGNET and LED, reading the current magnetic field direction and rendering it as a color on the LED.
As you twist the module, the color changes.
For example there is a particular direction for pure red, as well as all other colors.
The code
reads the magnetic field direction, scales the values to 0-255, and sets the LED color.

\subsection{Egg Timer}\index{Example!Potentiometer}\index{Example!Beeper}

Source code: \href{https://github.com/jamesbowman/i2cdriver/blob/master/python/samples/EDS-egg-timer.py}{EDS-egg-timer.py}

The demo uses POT, DIG2 and BEEPER to make a simple kitchen egg timer.
Twisting the POT sets a countdown time in seconds,
and after it's released the ticker starts counting.
When it reaches ``00" it flashes and beeps.

\subsection{Take-a-ticket}\index{Remote control}

Source code: \href{https://github.com/jamesbowman/i2cdriver/blob/master/python/samples/EDS-take-a-ticket.py}{EDS-take-a-ticket.py}

This demo runs a take-a-ticket display for a store or deli counter,
using REMOTE, DIG2 and BEEP modules.
It shows 2-digit ``now serving" number, and each time '+' is
pressed on the remote it increments the counter and
makes a beep, so the next customer can be served.
Pressing '-' turns the number back one.

\newpage
\section{Technical notes}

\subsection{Port names}\index{USB!ports}

The serial port that \iicdriver{} appears at depends on your operating system.

On \textbf{Windows}, it appears as COM1, COM2, COM3 etc.
You can use the Device Manager or the \mach{MODE} command to display the available ports.
\href{https://plugable.com/2011/07/04/how-to-change-the-com-port-for-a-usb-serial-adapter-on-windows-7/}{This article}
describes how to set a device to a fixed port.

On \textbf{Linux}, it appears as \mach{/dev/ttyUSB0}, 1, 2 etc.
The actual number depends on the order that devices were added.
However it also appears as something like:
\begin{lstlisting}
    /dev/serial/by-id/usb-FTDI_FT230X_Basic_UART_DO00QS8D-if00-port0
\end{lstlisting}
Where \mach{DO00QS8D} is the serial code of the \iicdriver{} (which is printed on the bottom of each \iicdriver{}).
This is longer, of course, but always the same for a given device.

Similarly on \textbf{Mac OS}, the \iicdriver{} appears as \mach{/dev/cu.usbserial-DO00QS8D}.

\subsection{Decreasing the USB latency timer}\index{USB!latency}

\iicdriver{} performance can be increased by setting the USB latency timer to its minimum value of 1 ms.
This can increase the speed of two-way \iic{} traffic by up to 10X.

On \textbf{Linux} do:

\begin{lstlisting}
    setserial /dev/ttyUSB0 low_latency
\end{lstlisting}

On \textbf{Windows} and \textbf{Mac OS} follow
\href{https://projectgus.com/2011/10/notes-on-ftdi-latency-with-arduino/}{these instructions}.

\subsection{Temperature sensor}\index{temperature sensor}

The temperature sensor is located in the on-board EFM8 microcontroller.
It is calibrated at manufacture to within 2 \degc.

\newpage
\subsection{Raw protocol}\index{protocol}

\iicdriver{} uses a serial protocol to send and receive \iic{} commands.
Connect to the \iicdriver{} at 1M baud, 8 bits, no parity, 1 stop bit (1000000 8N1).

Because many \iicdriver{} commands are ASCII, you can control it interactively from any
terminal application that can connect at 1M baud.
For example typing \mach{u} and \mach{s} toggles the CS line and \mach{?} displays the status info.

Commands are:

\gap\begin{tabular}{ll}
\hline
  \mach{?}        & transmit status info \\
  \mach{e} $byte$ & echo $byte$\\
\\
  \mach{1}        & set speed to 100 KHz\\
  \mach{4}        & set speed to 400 KHz\\
  \mach{s} $addr$ & send START/addr, return status\\
  0x80-bf         & read 1-64 bytes, NACK the final byte\\
  0xc0-ff         & write 1-64 bytes\\
  \mach{a} $N$    & read N bytes, ACK every byte\\
  \mach{p}        & send STOP\\
  \mach{x}        & reset \iic{} bus\\
  \mach{r}        & register read\\
  \mach{d}        & scan devices, return 112 status bytes\\
\\
  \mach{m}        & enter monitor mode\\
  \mach{c}        & enter capture mode\\
  \mach{b}        & enter bitbang mode\\
  \mach{i}        & leave bitmang, return to \iic{} mode\\
\\
  \mach{u} $byte$ & set pullup control lines\\
  \mach{v}        & start analog voltage measurement\\
  \mach{w}        & read voltage measurement result\\
\hline
\end{tabular}\gap

So for example to send this sequence:

\png{img/i2cdriver/hero3}

The host should send:

\gap\begin{tabular}{ll}
\mach{s} \mach{0x90}    & Start write to device 45 \\
\mach{0xc0} \mach{0x7a} & Write 1 byte \\
\mach{s} \mach{0x91}    & Start read from device 45 \\
\mach{0x80}          & Read 1 byte \\
\mach{p}             & Stop \\
\end{tabular}\gap

The status response is always 80 characters, space padded. For example::

\begin{lstlisting}
[i2cdriver1 DO01JUOO 000000061 4.971 000 23.8 I 1 1 100 24 ffff                ]
\end{lstlisting}

The fields are space-delimited:

\gap\begin{tabular}{ll}
\hline
identifier     & always \mach{i2cdriver1} \\
serial         & serial code identifier \\
uptime         & \iicdriver{} uptime 0-999999999, in seconds \\
voltage        & USB bus voltage, in volts \\
current        & attached device current, in mA \\
temperature    & junction temperature, in \degc \\
mode           & current mode, \mach{I} for \iic{}, \mach{B} for bitbang \\
SDA            & SDA line state, 0 or 1 \\
SCL            & SCL line state, 0 or 1 \\
speed          & \iic{} bus speed, in KHz \index{speed}\\
pullups        & pullup state byte \\
crc            & 16-bit CRC of all input and output bytes (CRC-16-CCITT) \index{CRC} \\
\hline\end{tabular}\gap

The sample \mach{confirm.py} shows the CRC-16-CCITT calculation.

\subsection{Pull-up resistors}\index{pull-ups}

\iicdriver{} has 6 programmable pull-up resistors, 3 each for SDA and SCL.
6 control bits each enable or disable a pull-up resistor. These bits are:

\begin{center}\begin{tabular}{ll}
\hline
bit & resistor \\
\hline
 0  & 2.2K to SDA \\
 1  & 4.3K to SDA \\
 2  & 4.7K to SDA \\
 3  & 2.2K to SCL \\
 4  & 4.3K to SCL \\
 5  & 4.7K to SCL \\
\hline
\end{tabular}\end{center}\gap

At boot the two 4.7K resistors are enabled.
By setting combinations of parallel resistors, a range of pull-up strengths can be achieved:

\begin{center}\begin{tabular}{cccl}
\hline
4.7K & 4.3K & 2.2K & pull-up strength \\
\hline
 0   &  0   &   0  & 0 (i.e. no pull-up) \\
 0   &  0   &   1  & 2.2K \\
 0   &  1   &   0  & 4.3K \\
 0   &  1   &   1  & 1.5K \\
 1   &  0   &   0  & 4.7K \\
 1   &  0   &   1  & 1.5K \\
 1   &  1   &   0  & 2.2K \\
 1   &  1   &   1  & 1.1K \\
\hline
\end{tabular}\end{center}\gap

Ordering this by useful resistances, the 3-bit combinations are:

\begin{center}\begin{tabular}{cl}
\hline
3-bit value & Resistance \\
\hline
  0         & 0 \\
  1         & 2.2K \\
  2         & 4.3K \\
  4         & 4.7K \\
  5         & 1.5K \\
  7         & 1.1K \\
\hline
\end{tabular}\end{center}\gap

In Python, the pullups are controlled by the \mach{setpullups()} method, and the state can be read from the \mach{pullups} variable.
Both are 6-bit values as above.

The GUI has a control for the pull-up resistors.
It sets the same pull-up strength for both SDA and SCL.

\newpage
\subsection{Specifications}\label{electrical-characteristics}

\subsubsection*{DC characteristics}
\vspace{10 pt}
{\renewcommand{\arraystretch}{1.2}% for the vertical padding

\begin{tabularx}{\linewidth}{XC{40pt}C{40pt}C{40pt}C{40pt}}
\heavyline
& min & typ & max & units \\ \heavyline

Voltage accuracy              && 0.01 && V            \\ \hline
Current accuracy              && 5 && mA              \\ \hline
Temperature accuracy          && $\pm$ 2 && \degc            \\ \hline
SDA,SCL & & & & \\
\hspace{10pt}low voltage & & & 0.6 & V \\
\hspace{10pt}high voltage & 2.7 &   & 5.8 & V \\ \hline
Output current        & & & 470 & mA                  \\ \hline
Current consumption   & & 25 & & mA                   \\ \hline

\end{tabularx}}
\vspace{10 pt}

\subsubsection*{AC characteristics}
\vspace{10 pt}

{\renewcommand{\arraystretch}{1.2}% for the vertical padding
\begin{tabularx}{\linewidth}{XC{40pt}C{40pt}C{40pt}C{40pt}}
\heavyline
& min & typ & max & units \\ \heavyline

\iic{} speed                     &100& &400& Kbps   \\ \hline \index{uptime}
Uptime accuracy               && 150 && ppm           \\ \hline
Uptime rollover               && 31.7 && years        \\ \hline
Startup time & & & 200 & ms \\ \hline
\end{tabularx}}
\vspace{10 pt}

\section{Support information}

Technical and product support is available at
\href{mailto:support@i2cdriver.com}{support@i2cdriver.com}

\iicdriver{} is built and maintained by
\href{https://excamera.com}{Excamera Labs}.

\newpage
\raggedright
\addcontentsline{toc}{section}{Index}
\renewcommand{\indexname}{Index}
\printindex

\end{document}
